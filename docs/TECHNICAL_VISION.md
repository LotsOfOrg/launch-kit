# FastHTML SaaS Toolkit Vision

## Package Name: `launch-kit`

A transparent, composable toolkit for building production-ready SaaS applications with FastHTML. Built using nbdev for literate programming and integrated testing, launch-kit follows MonsterUI patterns and FastHTML conventions - providing utilities that show exactly what they do, not black box abstractions. Every integration is visible, every component is composable, and every utility follows the "transparent, not magic" philosophy.

## Core Architecture

### 1. nbdev-Based Package Structure

```
launch-kit/
├── settings.ini              # nbdev configuration
├── setup.py                  # Generated by nbdev
├── README.md                 # Generated from index.ipynb
├── LICENSE
├── MANIFEST.in
├── nbs/                      # All development in notebooks
│   ├── index.ipynb          # Package overview & docs
│   ├── 00_core.ipynb        # Core utilities and base classes
│   ├── 01_config.ipynb      # Configuration management
│   ├── 02_database.ipynb    # Database helpers & models
│   ├── 03_auth.ipynb        # Authentication system
│   ├── 04_auth_providers.ipynb  # OAuth & magic links
│   ├── 05_permissions.ipynb # RBAC & authorization
│   ├── 06_admin.ipynb       # Admin dashboard
│   ├── 07_admin_components.ipynb # Admin UI components
│   ├── 08_teams.ipynb       # Team management
│   ├── 09_billing.ipynb     # Subscription management
│   ├── 10_billing_providers.ipynb # Stripe, Paddle, etc.
│   ├── 11_api.ipynb         # API key management
│   ├── 12_notifications.ipynb # Email & in-app notifications
│   ├── 13_ui_components.ipynb # Reusable UI components
│   ├── 14_ui_forms.ipynb    # Form helpers & validation
│   ├── 15_middleware.ipynb  # CSRF, rate limiting, etc.
│   ├── 16_cli.ipynb         # CLI tools
│   ├── 17_testing.ipynb     # Testing utilities
│   │
│   ├── examples/            # Example notebooks
│   │   ├── 01_quickstart.ipynb
│   │   ├── 02_custom_auth.ipynb
│   │   ├── 03_admin_customization.ipynb
│   │   ├── 04_billing_integration.ipynb
│   │   └── 05_full_saas_app.ipynb
│   │
│   └── tutorials/           # Step-by-step tutorials
│       ├── 01_getting_started.ipynb
│       ├── 02_authentication.ipynb
│       ├── 03_building_admin.ipynb
│       └── 04_deployment.ipynb
│
├── launch_kit/              # Generated Python package
│   ├── __init__.py         # Auto-generated exports
│   ├── core.py            # From 00_core.ipynb
│   ├── config.py          # From 01_config.ipynb
│   ├── database.py        # From 02_database.ipynb
│   ├── auth.py            # From 03_auth.ipynb
│   └── ...                # All other modules
│
├── docs/                    # Generated documentation
│   ├── index.html          # From notebooks
│   ├── core.html
│   ├── auth.html
│   └── ...
│
├── tests/                   # Tests extracted from notebooks
│   └── test_*.py           # Auto-generated from notebook cells
│
└── templates/              # Project templates
    ├── basic/
    ├── advanced/
    └── enterprise/
```

### 2. nbdev Development Approach

#### Notebook Organization
Each notebook follows nbdev conventions with clear exports, tests, and documentation:

```python
# In 03_auth.ipynb
#| default_exp auth
#| export
from fasthtml.common import *
from dataclasses import dataclass
import bcrypt

#| export
@dataclass
class AuthConfig:
    """Configuration for authentication system
    
    All settings are documented with examples in the notebook cells.
    Tests demonstrate various configuration scenarios.
    """
    session_key: str = "auth"
    session_lifetime: int = 86400
    require_email_verification: bool = True
    enable_2fa: bool = False
    max_login_attempts: int = 5
    lockout_duration: int = 300

#| export
class Auth:
    """Main authentication class with comprehensive examples"""
    def __init__(self, app, config: AuthConfig = None):
        self.config = config or AuthConfig()
        self._setup_routes()

# Test cells demonstrate usage
#| test
config = AuthConfig(require_email_verification=False)
assert config.session_key == "auth"
assert not config.require_email_verification

# Test password hashing
auth = Auth(None, config)
hashed = auth.hash_password("secure_password123")
assert auth.verify_password("secure_password123", hashed)
assert not auth.verify_password("wrong_password", hashed)

# Test session creation
session_token = auth.create_session(user_id=1)
assert len(session_token) == 64  # 32 bytes hex encoded

# Visual test - render login form
login_form = auth.render_login_form()
display(login_form)  # Shows form in notebook
```

#### Documentation Through Examples
Each notebook includes rich examples that become documentation:

```python
# In examples/01_quickstart.ipynb
#| doc
"""
# FastHTML SaaS Quickstart

This notebook demonstrates setting up a basic SaaS application
with authentication and admin panel in under 50 lines of code.
"""

from fasthtml.common import *
from launch_kit.auth import auth_beforeware, setup_auth_routes
from launch_kit.database import setup_database
from launch_kit.admin import setup_admin_routes

# Create YOUR FastHTML app - no magic
app = fast_app(
    before=auth_beforeware,  # Visible auth middleware
    hdrs=(MonsterUI(),)      # Explicit UI
)

# Set up features explicitly
db = setup_database(app, "sqlite:///myapp.db")
setup_auth_routes(app, db)
setup_admin_routes(app, db)

# Add your custom routes
@rt("/")
def home(sess):
    if sess.get('user_id'):
        user = db.query("SELECT email FROM users WHERE id = ?", [sess['user_id']])[0]
        return f"Welcome {user['email']}!"
    return "Welcome! Please login."

# Run the app
if __name__ == "__main__":
    serve()  # FastHTML's serve function
```

### 3. Design Philosophy: Transparent Utilities

The toolkit follows a "transparent, not magic" approach inspired by MonsterUI and FastHTML patterns:

#### Core Principles
1. **No wrapper functions** - Use FastHTML's `fast_app()` directly
2. **Explicit over implicit** - All integrations are visible in your code
3. **Composable utilities** - Small, focused functions that work together
4. **Visible integration** - You see exactly what's added to your app
5. **FastHTML patterns first** - Use beforeware, not decorators; use HTMX, not custom JS

#### Example: Setting Up Authentication
```python
# BAD: Hidden magic
app = create_saas_app(features=["auth", "admin"])  # What routes were added? What middleware?

# GOOD: Transparent utilities
from fasthtml.common import *
from launch_kit.auth import AuthRoutes
from launch_kit.database import database
from monsterui import *

# You create the FastHTML app
app, rt = fast_app(
    hdrs=(MonsterUI(),)  # Explicit UI framework
)

# You explicitly set up features
db = database("myapp.db")
auth = AuthRoutes(db)

# You control the routes
@rt("/auth/login")
def login_page():
    return auth.login_page()

@rt("/auth/login", methods=["POST"])
async def login(req, sess):
    return await auth.login(req, sess)
```

This transparency means:
- You understand your application's structure
- You can debug issues easily
- You can customize any part
- You learn FastHTML patterns, not framework-specific magic

### 4. Key Abstractions

#### Unified Configuration (from 01_config.ipynb)
```python
#| export
import os
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any
from datetime import timedelta
from pathlib import Path

@dataclass
class SaaSConfig:
    """Central configuration for all SaaS features
    
    Examples in notebook show different configuration scenarios:
    - Basic auth-only setup
    - Full-featured enterprise configuration
    - Custom provider configurations
    """
    # Core settings
    app_name: str
    secret_key: str = field(default_factory=lambda: os.urandom(32).hex())
    database_url: str = "sqlite:///data/app.db"
    base_url: str = "http://localhost:5000"  # For email links, webhooks
    
    # Paths
    static_path: Path = Path("static")
    template_path: Path = Path("templates")
    upload_path: Path = Path("uploads")
    
    # Feature flags with granular control
    features: Dict[str, bool] = field(default_factory=lambda: {
        "auth": True,
        "auth.registration": True,
        "auth.email_verification": True,
        "auth.password_reset": True,
        "auth.2fa": False,
        "teams": False,
        "teams.invitations": False,
        "billing": False,
        "billing.trials": False,
        "api": False,
        "api.rate_limiting": False,
        "admin": True,
        "admin.impersonation": False,
    })
    
    # Provider configuration
    auth_providers: List[str] = field(default_factory=lambda: ["password"])
    oauth_providers: Dict[str, Dict[str, str]] = field(default_factory=dict)
    billing_provider: Optional[str] = None
    billing_config: Dict[str, Any] = field(default_factory=dict)
    email_provider: str = "console"  # console, smtp, resend, postmark
    email_config: Dict[str, Any] = field(default_factory=dict)
    
    # Security settings
    session_lifetime: timedelta = timedelta(days=30)
    require_email_verification: bool = True
    enforce_2fa: bool = False
    password_min_length: int = 8
    password_require_special: bool = True
    max_login_attempts: int = 5
    lockout_duration: timedelta = timedelta(minutes=15)
    
    # Performance settings
    cache_enabled: bool = True
    cache_backend: str = "memory"  # memory, redis, memcached
    db_pool_size: int = 5
    db_max_overflow: int = 10
    
    def __post_init__(self):
        """Validate configuration after initialization"""
        # Create directories if they don't exist
        for path in [self.static_path, self.template_path, self.upload_path]:
            path.mkdir(parents=True, exist_ok=True)
        
        # Validate feature dependencies
        if self.features.get("teams") and not self.features.get("auth"):
            raise ValueError("Teams feature requires auth to be enabled")
        
        if self.features.get("billing") and not self.features.get("auth"):
            raise ValueError("Billing feature requires auth to be enabled")

# Test different configurations
#| test
basic_config = SaaSConfig(app_name="Test App")
assert basic_config.features["auth"] == True
assert basic_config.features["teams"] == False

enterprise_config = SaaSConfig(
    app_name="Enterprise App",
    features={"auth": True, "teams": True, "billing": True, "api": True, "admin": True},
    auth_providers=["password", "google", "saml"],
    billing_provider="stripe",
    enforce_2fa=True
)
assert enterprise_config.enforce_2fa == True
```

#### Transparent Setup Utilities (from 00_core.ipynb)
```python
#| export
import os
from typing import Dict, List, Optional, Any
from fasthtml.common import *
from monsterui import *

# Beforeware utilities - visible middleware for FastHTML
def session_auth_beforeware(req, sess):
    """Validate session tokens - transparent auth check"""
    # This beforeware ensures session tokens are still valid
    token = sess.get('auth_token')
    if not token:
        return  # No session, nothing to validate
    
    # Check if token is still valid in database
    from .database import validate_session_token
    if not validate_session_token(token):
        # Invalid token, clear session
        sess.clear()
        return

def rate_limit_beforeware(req, sess):
    """Rate limiting beforeware - visible protection"""
    # Check rate limits
    from .security import check_rate_limit
    ip = req.headers.get('X-Forwarded-For', req.client.host)
    
    if not check_rate_limit(ip, req.url.path):
        return Response("Rate limit exceeded", status_code=429)

def csrf_beforeware(req, sess):
    """CSRF protection for FastHTML - explicit security"""
    if req.method in ['POST', 'PUT', 'DELETE']:
        token = req.headers.get('X-CSRF-Token')
        if token != sess.get('csrf_token'):
            return Response("CSRF validation failed", status_code=403)

# Database setup - you see the connection
def setup_database(app, database_url: str):
    """Set up database connection - returns db object you can use"""
    import sqlite3
    from .models import create_tables
    
    # Create connection
    if database_url.startswith('sqlite:///'):
        db_path = database_url.replace('sqlite:///', '')
        db = sqlite3.connect(db_path, check_same_thread=False)
        db.row_factory = sqlite3.Row
    else:
        # PostgreSQL, MySQL, etc.
        pass
    
    # Create tables
    create_tables(db)
    
    # Make db available to routes
    app.db = db
    return db

# No route setup utilities - you control your routes directly
# Instead, we provide route handler classes:

class AuthRoutes:
    """Authentication route handlers - you wire them up"""
    def __init__(self, db):
        self.db = db
    
    def login_page(self):
        """GET /auth/login - Login form"""
        return Card(
            H2("Login"),
            Form(
                FormField(
                    Label("Email"),
                    Input(type="email", name="email", required=True)
                ),
                FormField(
                    Label("Password"),
                    Input(type="password", name="password", required=True)
                ),
                Button("Login", type="submit", variant="primary"),
                method="post",
                action="/auth/login"
            )
        )
    
    async def login(self, req, sess):
        """POST /auth/login - Handle login"""
        form = await req.form()
        email = form.get("email")
        password = form.get("password")
        
        # Find user
        user = self.db.query("SELECT * FROM users WHERE email = ?", [email])
        
        if user and verify_password(password, user[0]['password_hash']):
            # Store user ID in session
            sess['user_id'] = user[0]['id']
            return RedirectResponse("/dashboard", status_code=303)
        
        return Alert("Invalid credentials", variant="error")
    
    def logout(self, sess):
        """GET /auth/logout - Clear session"""
        sess.clear()
        return RedirectResponse("/")

class AdminRoutes:
    """Admin route handlers - transparent admin panel"""
    def __init__(self, db):
        self.db = db
    
    def is_admin(self, sess):
        """Check if current user is admin"""
        user_id = sess.get('user_id')
        if not user_id:
            return False
        
        user = self.db.query(
            "SELECT is_admin FROM users WHERE id = ?",
            [user_id]
        )
        return user and user[0]['is_admin']
    
    def admin_dashboard(self, sess):
        """GET /admin - Admin dashboard"""
        if not self.is_admin(sess):
            return RedirectResponse("/auth/login")
        
        # Get stats
        user_count = self.db.query("SELECT COUNT(*) as count FROM users")[0]['count']
        
        return DashboardLayout(
            PageHeader("Admin Dashboard"),
            Grid(
                StatsCard("Total Users", user_count),
                StatsCard("Active Today", "--"),
                cols=2
            )
        )

# Example: Building a SaaS app with transparent utilities
#| doc
"""
# Building a SaaS App - The Transparent Way

No magic, no hidden behavior. You build your FastHTML app and add features explicitly:
"""

#| export
def create_example_app():
    """Example showing the transparent approach"""
    # 1. Create YOUR FastHTML app - no magic factory
    app, rt = fast_app(
        hdrs=(MonsterUI(),)  # Explicit UI framework
    )
    
    # 2. Set up database - simple and direct
    db = database("myapp.db")
    
    # 3. Create route handlers (not auto-registered)
    auth = AuthRoutes(db)
    admin = AdminRoutes(db)
    
    # 4. Wire up routes explicitly - YOU control everything
    @rt("/")
    def home(sess):
        if sess.get('user_id'):
            return RedirectResponse("/dashboard")
        return Container(
            H1("Welcome to My SaaS"),
            Button("Get Started", href="/auth/register")
        )
    
    @rt("/dashboard")
    def dashboard(sess):
        if not sess.get('user_id'):
            return RedirectResponse("/auth/login")
        
        # Get user from session
        user = db.query(
            "SELECT * FROM users WHERE id = ?",
            [sess['user_id']]
        )[0]
        
        return Container(
            H1(f"Welcome {user['email']}!"),
            # Your dashboard content
        )
    
    # 5. Wire up auth routes - explicit, visible
    @rt("/auth/login")
    def login_page():
        return auth.login_page()
    
    @rt("/auth/login", methods=["POST"])
    async def login(req, sess):
        return await auth.login(req, sess)
    
    @rt("/auth/logout")
    def logout(sess):
        return auth.logout(sess)
    
    # 6. Wire up admin routes - you choose which ones
    @rt("/admin")
    def admin_dashboard(sess):
        return admin.admin_dashboard(sess)
    
    return app

# Test the transparent approach
#| test
app = create_example_app()
assert app is not None
assert hasattr(app, 'db')  # Database is accessible
print("✓ Transparent app creation works")
```

### 5. Feature Modules (Developed in Notebooks)

Each feature module is developed in its own notebook with inline tests and examples:

#### Authentication Module (03_auth.ipynb, 04_auth_providers.ipynb)
```python
#| doc
"""
# Authentication System

This notebook implements a complete authentication system for FastHTML apps.
Each section includes examples and tests demonstrating the functionality.
"""

#| export
import bcrypt
import secrets
import os
from datetime import datetime, timedelta
from typing import Optional, Dict, Any
from dataclasses import dataclass
from fasthtml.common import *

@dataclass
class User:
    """User model with authentication fields"""
    id: int
    email: str
    username: str
    password_hash: str
    email_verified: bool = False
    is_admin: bool = False
    is_active: bool = True
    created_at: datetime = field(default_factory=datetime.utcnow)
    last_login: Optional[datetime] = None
    failed_login_attempts: int = 0
    locked_until: Optional[datetime] = None
    two_factor_secret: Optional[str] = None

#| export
class AuthRoutes:
    """
    Authentication route handlers - transparent authentication system.
    
    This class provides route handlers that you explicitly wire up to your app.
    No magic, no automatic route registration - you control everything.
    
    Features:
    - Session-based auth using FastHTML's session parameter
    - Password authentication with bcrypt
    - Email verification flow
    - Password reset functionality
    - Rate limiting and account lockout
    - Two-factor authentication
    """
    
    def __init__(self, db, config=None):
        self.db = db
        self.config = config or {}
    
    def hash_password(self, password: str) -> str:
        """Hash password using bcrypt with cost factor 12"""
        return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt(12)).decode('utf-8')
    
    def verify_password(self, password: str, hashed: str) -> bool:
        """Verify password against hash (timing-safe)"""
        return bcrypt.checkpw(password.encode('utf-8'), hashed.encode('utf-8'))
    
    def create_session(self, user_id: int) -> str:
        """Create secure session token"""
        token = secrets.token_urlsafe(32)
        # Store in database with expiry
        expires_at = datetime.utcnow() + timedelta(days=30)
        self.db.execute(
            "INSERT INTO sessions (token, user_id, expires_at) VALUES (?, ?, ?)",
            (token, user_id, expires_at)
        )
        self.db.commit()
        return token
    
    # Route handlers - to be manually registered with your app
    
    def login_page(self):
        """GET /auth/login - Login page"""
        return Card(
            H2("Login"),
            Form(
                FormField(
                    Label("Email"),
                    Input(type="email", name="email", required=True)
                ),
                FormField(
                    Label("Password"),
                    Input(type="password", name="password", required=True)
                ),
                Checkbox(
                    name="remember_me", 
                    label="Remember me"
                ),
                Button("Login", type="submit", variant="primary", full_width=True),
                method="post",
                action="/auth/login",
                hx_post="/auth/login",
                hx_target="#content"
            ),
            Text(
                "Don't have an account? ",
                Link("Sign up", href="/auth/register"),
                align="center",
                cls="mt-4"
            ),
            max_width="md",
            mx="auto"
        )
    
    async def login(self, req, sess):
        """POST /auth/login - Handle login with FastHTML session"""
        form = await req.form()
        email = form.get("email")
        password = form.get("password")
        remember = form.get("remember_me") == "on"
        
        # Find user and verify password
        cursor = self.db.execute("SELECT * FROM users WHERE email = ?", (email,))
        user = cursor.fetchone()
        
        if not user or not self.verify_password(password, user['password_hash']):
            return Alert(
                "Invalid email or password",
                variant="error",
                hx_swap_oob="true"
            )
        
        # Check if account is locked
        if user['locked_until'] and datetime.fromisoformat(user['locked_until']) > datetime.utcnow():
            remaining = (datetime.fromisoformat(user['locked_until']) - datetime.utcnow()).seconds // 60
            return Alert(
                f"Account locked. Try again in {remaining} minutes",
                variant="warning",
                hx_swap_oob="true"
            )
        
        # Create session using FastHTML's session
        token = self.create_session(user['id'])
        sess['auth_token'] = token
        sess['user_id'] = user['id']
        
        # Update last login
        self.db.execute(
            "UPDATE users SET last_login = ?, failed_login_attempts = 0 WHERE id = ?",
            (datetime.utcnow(), user['id'])
        )
        self.db.commit()
        
        return RedirectResponse("/dashboard", status_code=303)
    
    def logout(self, sess):
        """GET /auth/logout - Handle logout"""
        if 'auth_token' in sess:
            # Invalidate session in database
            self.db.execute("DELETE FROM sessions WHERE token = ?", (sess['auth_token'],))
            self.db.commit()
        sess.clear()
        return RedirectResponse("/")
    
    def register_page(self):
        """GET /auth/register - Registration page"""
        return Card(
            H2("Create Account"),
            Form(
                FormField(
                    Label("Email"),
                    Input(type="email", name="email", required=True)
                ),
                FormField(
                    Label("Username"),
                    Input(type="text", name="username", required=True)
                ),
                FormField(
                    Label("Password"),
                    Input(type="password", name="password", required=True, 
                          minlength="8")
                ),
                FormField(
                    Label("Confirm Password"),
                    Input(type="password", name="confirm_password", required=True)
                ),
                Button("Create Account", type="submit", variant="primary", full_width=True),
                method="post",
                action="/auth/register"
            ),
            Text(
                "Already have an account? ",
                Link("Sign in", href="/auth/login"),
                align="center",
                cls="mt-4"
            ),
            max_width="md",
            mx="auto"
        )
    
    async def register(self, req, sess):
        """POST /auth/register - Handle registration"""
        form = await req.form()
        email = form.get("email")
        username = form.get("username")
        password = form.get("password")
        confirm_password = form.get("confirm_password")
        
        if password != confirm_password:
            return Alert("Passwords do not match", variant="error")
        
        # Check if user exists
        existing = self.db.execute(
            "SELECT id FROM users WHERE email = ? OR username = ?",
            (email, username)
        ).fetchone()
        
        if existing:
            return Alert("Email or username already taken", variant="error")
        
        # Create user
        password_hash = self.hash_password(password)
        cursor = self.db.execute(
            """INSERT INTO users (email, username, password_hash, created_at) 
               VALUES (?, ?, ?, ?)""",
            (email, username, password_hash, datetime.utcnow())
        )
        user_id = cursor.lastrowid
        self.db.commit()
        
        # Auto-login after registration
        token = self.create_session(user_id)
        sess['auth_token'] = token
        sess['user_id'] = user_id
        
        return RedirectResponse("/dashboard", status_code=303)

# Example: How to use the transparent auth system
#| doc
"""
## Using the Authentication System

Here's how to add authentication to your FastHTML app - completely transparent:
"""

#| export
def create_app_with_auth():
    """Example showing transparent auth integration"""
    from fasthtml.common import *
    
    # 1. Create YOUR app - no magic
    app, rt = fast_app()
    
    # 2. Set up database
    db = database("app.db")
    
    # 3. Create auth routes handler
    auth = AuthRoutes(db, config={
        'session_lifetime': timedelta(days=30)
    })
    
    # 4. Explicitly register auth routes - you see exactly what's added
    @rt("/auth/login")
    def login_page():
        return auth.login_page()
    
    @rt("/auth/login", methods=["POST"])
    async def login(req, sess):
        return await auth.login(req, sess)
    
    @rt("/auth/logout")
    def logout(sess):
        return auth.logout(sess)
    
    @rt("/auth/register")
    def register_page():
        return auth.register_page()
    
    @rt("/auth/register", methods=["POST"])
    async def register(req, sess):
        return await auth.register(req, sess)
    
    # 5. Add your own routes with session-based auth
    @rt("/")
    def home(sess):
        if 'user_id' in sess:
            return RedirectResponse("/dashboard")
        return Container(
            H1("Welcome to My SaaS"),
            Button("Get Started", href="/auth/register", variant="primary")
        )
    
    @rt("/dashboard")
    def dashboard(sess):
        if 'user_id' not in sess:
            return RedirectResponse("/auth/login")
        
        # Get user from session
        user = db.execute(
            "SELECT * FROM users WHERE id = ?", 
            (sess['user_id'],)
        ).fetchone()
        
        return Container(
            H1(f"Welcome {user['email']}!"),
            Button("Logout", href="/auth/logout", variant="secondary")
        )
    
    return app

# Test the transparent approach
#| test
app = create_app_with_auth()
assert app is not None
print("✓ Transparent auth app creation works")
```

#### Admin Module (06_admin.ipynb, 07_admin_components.ipynb)
```python
#| doc
"""
# Admin Dashboard

This notebook creates a flexible admin dashboard system.
Examples show how to customize for different use cases.
"""

#| export
import os
import json
from typing import List, Dict, Any, Optional
from datetime import datetime, timedelta
from fasthtml.common import *

class AdminRoutes:
    """
    Admin dashboard route handlers - transparent admin system.
    
    This class provides route handlers that you explicitly wire up to your app.
    No automatic route registration, no hidden behavior.
    
    Features:
    - User management with search/filter
    - System metrics and monitoring
    - Audit logging with search
    - Customizable UI components
    - Session-based admin checks
    """
    
    def __init__(self, db, config=None):
        self.db = db
        self.config = config or {}
    
    def is_admin(self, sess):
        """Check if current session user is admin"""
        if 'user_id' not in sess:
            return False
        
        user = self.db.execute(
            "SELECT is_admin FROM users WHERE id = ?",
            (sess['user_id'],)
        ).fetchone()
        
        return user and user['is_admin']
    
    def get_dashboard_stats(self):
        """Get dashboard statistics"""
        stats = {}
        stats['total_users'] = self.db.execute(
            "SELECT COUNT(*) as count FROM users"
        ).fetchone()['count']
        
        stats['active_today'] = self.db.execute(
            """SELECT COUNT(*) as count FROM users 
               WHERE last_login > datetime('now', '-1 day')"""
        ).fetchone()['count']
        
        stats['new_this_week'] = self.db.execute(
            """SELECT COUNT(*) as count FROM users 
               WHERE created_at > datetime('now', '-7 days')"""
        ).fetchone()['count']
        
        stats['revenue_mtd'] = 12450.00  # Example
        return stats
    
    def get_recent_activity(self):
        """Get recent activity log entries"""
        return self.db.execute(
            """SELECT * FROM activity_log 
               ORDER BY created_at DESC LIMIT 10"""
        ).fetchall()
    
    # Route handlers - to be manually registered with your app
    
    def admin_dashboard(self, sess):
        """GET /admin - Admin dashboard"""
        if not self.is_admin(sess):
            return RedirectResponse("/auth/login")
        
        stats = self.get_dashboard_stats()
        return DashboardLayout(
            PageHeader("Admin Dashboard"),
            
            # Stats cards
            Grid(
                StatsCard(
                    title="Total Users",
                    value=stats['total_users'],
                    icon="users",
                    trend="+12%"
                ),
                StatsCard(
                    title="Active Today",
                    value=stats['active_today'],
                    icon="activity",
                    trend="+5%"
                ),
                StatsCard(
                    title="New This Week",
                    value=stats['new_this_week'],
                    icon="user-plus",
                    trend="+23%"
                ),
                StatsCard(
                    title="Revenue MTD",
                    value=f"${stats['revenue_mtd']:,.2f}",
                    icon="dollar-sign",
                    trend="+8%"
                ),
                cols=4,
                gap=4
            ),
            
            # Charts and activity
            Grid(
                Card(
                    CardHeader("User Growth"),
                    Chart(
                        id="user-growth-chart",
                        type="line",
                        height="300px",
                        hx_get="/admin/charts/user-growth",
                        hx_trigger="load"
                    )
                ),
                Card(
                    CardHeader("Recent Activity"),
                    ActivityFeed(self.get_recent_activity())
                ),
                cols=2,
                gap=6
            )
        )
    
    def user_management(self, req, sess):
        """GET /admin/users - User management page"""
        if not self.is_admin(sess):
            return RedirectResponse("/auth/login")
        
        # Get query parameters
        search = req.query_params.get('search', '')
        status = req.query_params.get('status', 'all')
        page = int(req.query_params.get('page', 1))
        
        users, total = self.get_users(search=search, status=status, page=page)
        
        return DashboardLayout(
            PageHeader("User Management"),
            
            # Search and filters
            Card(
                Form(
                    Flex(
                        SearchInput(
                            name="search",
                            placeholder="Search users...",
                            value=search,
                            width="256px"
                        ),
                        Select(
                            Option("All Users", value="all", selected=status=="all"),
                            Option("Active", value="active", selected=status=="active"),
                            Option("Inactive", value="inactive", selected=status=="inactive"),
                            Option("Admins", value="admin", selected=status=="admin"),
                            name="status"
                        ),
                        Button("Search", type="submit", variant="primary"),
                        gap=4,
                        align="center"
                    ),
                    method="get",
                    hx_get="/admin/users",
                    hx_target="#user-table",
                    hx_push_url="true"
                )
            ),
            
            # User table
            Div(
                Table(
                    Thead(
                        Tr(
                            Th("Username"),
                            Th("Email"),
                            Th("Status"),
                            Th("Created"),
                            Th("Last Login"),
                            Th("Actions")
                        )
                        ),
                        Tbody(
                            *[self.render_user_row(user) for user in users]
                        ),
                        cls="w-full"
                    ),
                    id="user-table"
                ),
                
                # Pagination
                self.render_pagination(page, total, per_page=20)
            )
    
    def render_user_row(self, user):
        """Render a single user row with actions"""
        return Tr(
            Td(user['username']),
            Td(user['email']),
            Td(
                Badge(
                    "Active" if user['is_active'] else "Inactive",
                    variant="success" if user['is_active'] else "neutral"
                )
            ),
            Td(user['created_at'][:10]),  # YYYY-MM-DD
            Td(user['last_login'][:16] if user['last_login'] else "Never"),  # YYYY-MM-DD HH:MM
            Td(
                ButtonGroup(
                    Button(
                        "Edit",
                        size="sm",
                        variant="secondary",
                        hx_get=f"/admin/users/{user['id']}/edit",
                        hx_target="#modal"
                    ),
                    Button(
                        "Disable" if user['is_active'] else "Enable",
                        size="sm",
                        variant="warning",
                        hx_post=f"/admin/users/{user['id']}/toggle",
                        hx_swap="outerHTML"
                    )
                )
            )
        )
    
    def get_users(self, search='', status='all', page=1, per_page=20):
        """Get users with filtering and pagination"""
        # Build query based on filters
        query = "SELECT * FROM users WHERE 1=1"
        params = []
        
        if search:
            query += " AND (email LIKE ? OR username LIKE ?)"
            search_param = f"%{search}%"
            params.extend([search_param, search_param])
        
        if status == 'active':
            query += " AND is_active = 1"
        elif status == 'inactive':
            query += " AND is_active = 0"
        elif status == 'admin':
            query += " AND is_admin = 1"
        
        # Get total count
        count_query = query.replace("SELECT *", "SELECT COUNT(*) as count")
        total = self.db.execute(count_query, params).fetchone()['count']
        
        # Add pagination
        query += f" LIMIT {per_page} OFFSET {(page - 1) * per_page}"
        users = self.db.execute(query, params).fetchall()
        
        return users, total

# Example: How to use the transparent admin system
#| doc
"""
## Using the Admin System

Here's how to add an admin panel to your FastHTML app - completely transparent:
"""

#| export
def create_app_with_admin():
    """Example showing transparent admin integration"""
    from fasthtml.common import *
    
    # 1. Create YOUR app
    app, rt = fast_app()
    
    # 2. Set up database
    db = database("app.db")
    
    # 3. Create auth and admin route handlers
    auth = AuthRoutes(db)
    admin = AdminRoutes(db)
    
    # 4. Explicitly register admin routes - you control everything
    @rt("/admin")
    def admin_dashboard(sess):
        return admin.admin_dashboard(sess)
    
    @rt("/admin/users")
    def user_management(req, sess):
        return admin.user_management(req, sess)
    
    @rt("/admin/users/{user_id}/edit")
    def edit_user(user_id: int, sess):
        if not admin.is_admin(sess):
            return Response("Unauthorized", status_code=403)
        return admin.edit_user_form(user_id)
    
    @rt("/admin/users/{user_id}/toggle", methods=["POST"])
    def toggle_user(user_id: int, sess):
        if not admin.is_admin(sess):
            return Response("Unauthorized", status_code=403)
        return admin.toggle_user_status(user_id)
    
    # 5. Wire up authentication routes
    @rt("/auth/login")
    def login_page():
        return auth.login_page()
    
    @rt("/auth/login", methods=["POST"])
    async def login(req, sess):
        return await auth.login(req, sess)
    
    @rt("/auth/logout")
    def logout(sess):
        return auth.logout(sess)
    
    # 6. Your app routes
    @rt("/")
    def home(sess):
        return Container(
            H1("My SaaS App"),
            Button("Admin Panel", href="/admin") if admin.is_admin(sess) else None,
            Button("Login", href="/auth/login") if 'user_id' not in sess else None
        )
    
    return app

# Test the transparent approach
#| test
app = create_app_with_admin()
assert app is not None
print("✓ Transparent admin app creation works")
```

#### Interactive Development Benefits
The nbdev approach provides several advantages:

1. **Live Documentation**: Each notebook cell can be executed to see results
2. **Integrated Testing**: Tests live alongside the code they test
3. **Visual Development**: UI components can be rendered in notebooks
4. **Exploratory Coding**: Try ideas interactively before committing

Example from a UI components notebook:
```python
# In 13_ui_components.ipynb
#| doc
"""Let's create a reusable data table component"""

#| export
import os
from fasthtml.common import *
from monsterui import *
from typing import List, Dict, Any, Optional, Callable

def DataTable(
    columns: List[str], 
    data: List[Dict[str, Any]], 
    actions: Optional[List[Callable]] = None,
    sortable: bool = True,
    filterable: bool = True,
    selectable: bool = False
):
    """Create a sortable, filterable data table with MonsterUI components"""
    
    table_id = f"table-{id(data)}"  # Unique ID for HTMX targeting
    
    return Container(
        # Filter input with MonsterUI SearchInput
        SearchInput(
            placeholder="Filter table...",
            hx_post=f"/tables/{table_id}/filter",
            hx_trigger="keyup changed delay:500ms",
            hx_target=f"#{table_id}",
            width="256px",
            cls="mb-4"
        ) if filterable else None,
        
        # Table
        Table(
            Thead(
                Tr(
                    *[
                        Th(
                            Div(
                                col,
                                I(cls="fas fa-sort ml-2") if sortable else None,
                                cls="flex items-center cursor-pointer" if sortable else "",
                                hx_get=f"/tables/{table_id}/sort?col={i}" if sortable else None,
                                hx_target=f"#{table_id}" if sortable else None
                            )
                        ) for i, col in enumerate(columns)
                    ],
                    Th("Actions") if actions else None
                )
            ),
            Tbody(
                *[
                    Tr(
                        *[
                            Td(
                                Checkbox(
                                    name="selected",
                                    value=row.get('id', i),
                                    cls="row-select"
                                ) if selectable and j == 0 else row.get(col.lower(), '')
                            ) for j, col in enumerate(columns)
                        ],
                        Td(
                            *[
                                Button(
                                    action.__name__.replace('_', ' ').title(),
                                    hx_post=f"/tables/{table_id}/action/{action.__name__}/{row.get('id', i)}",
                                    hx_swap="outerHTML",
                                    cls="btn btn-sm mr-1"
                                ) for action in (actions or [])
                            ]
                        ) if actions else None,
                        id=f"row-{row.get('id', i)}"
                    ) for i, row in enumerate(data)
                ]
            ),
            id=table_id,
            cls="w-full"
        ),
        
        # Bulk actions for selectable tables
        Div(
            Select(
                Option("Bulk Actions", value="", disabled=True, selected=True),
                Option("Delete Selected", value="delete"),
                Option("Export Selected", value="export"),
                name="bulk_action",
                cls="mr-2"
            ),
            Button(
                "Apply",
                hx_post=f"/tables/{table_id}/bulk",
                hx_include=".row-select:checked",
                cls="btn btn-primary"
            ),
            cls="mt-4 flex items-center"
        ) if selectable else None
    )

# Visual test - this renders in the notebook!
#| test
sample_data = [
    {"id": 1, "name": "John Doe", "email": "john@example.com", "role": "Admin", "status": "Active"},
    {"id": 2, "name": "Jane Smith", "email": "jane@example.com", "role": "User", "status": "Active"},
    {"id": 3, "name": "Bob Johnson", "email": "bob@example.com", "role": "User", "status": "Inactive"}
]

# Define actions
def edit_user(user_id): pass
def toggle_status(user_id): pass

table = DataTable(
    columns=["Name", "Email", "Role", "Status"],
    data=sample_data,
    actions=[edit_user, toggle_status],
    sortable=True,
    filterable=True,
    selectable=True
)
display(table)  # Shows rendered table in notebook

# Test that all features are present
table_html = str(table)
assert "Filter..." in table_html  # Filter input present
assert "fa-sort" in table_html  # Sort icons present
assert "checkbox" in table_html  # Selection checkboxes present
assert "Edit User" in table_html  # Action buttons present
assert "Bulk Actions" in table_html  # Bulk actions present
```

### 6. Developer Experience

#### nbdev Workflow Integration
The package leverages nbdev's features for an enhanced developer experience:

```bash
# Development workflow
nbdev_preview  # Live preview of docs while developing
nbdev_test     # Run all tests from notebooks
nbdev_export   # Export notebooks to Python modules
nbdev_clean    # Clean notebooks for git commits
nbdev_install_hooks  # Install git hooks for clean commits
```

#### CLI Tool (Developed in 16_cli.ipynb)
```bash
# Create new project
launch-kit new myapp --template=advanced

# Add features to existing project
launch-kit add billing --provider=stripe
launch-kit add auth --providers=google,github

# Database management
launch-kit db init
launch-kit db migrate
launch-kit db seed

# Development tools
launch-kit dev     # Run with hot reload
launch-kit test    # Run test suite
launch-kit deploy  # Deploy wizard
```

#### Project Templates

**Basic Template**
- Authentication (password only)
- User dashboard
- Settings page
- SQLite database

**Advanced Template**
- Multi-provider auth
- Team management
- Billing integration
- Admin dashboard
- PostgreSQL ready

**Enterprise Template**
- Everything in Advanced
- API management
- Advanced audit logging
- Multi-tenancy support
- Redis caching
- Background jobs

### 7. Integration with FastHTML

#### FastHTML Patterns First
The toolkit embraces FastHTML patterns over custom abstractions:
```python
#| export
import os
from typing import Dict, List, Optional, Any
from fasthtml.common import *
from launch_kit.database import get_user_by_token

# Direct session checks in route handlers
def check_auth(sess):
    """Simple auth check - transparent and debuggable"""
    return sess.get('user_id') is not None

def check_admin(sess, db):
    """Admin check - visible logic"""
    user_id = sess.get('user_id')
    if not user_id:
        return False
    user = db.query("SELECT is_admin FROM users WHERE id = ?", [user_id])
    return user and user[0]['is_admin']

def check_team_role(sess, team_id, required_role, db):
    """Check team membership and role"""
    user_id = sess.get('user_id')
    if not user_id:
        return False
    
    member = db.query(
        "SELECT role FROM team_members WHERE user_id = ? AND team_id = ?",
        [user_id, team_id]
    )
    if not member:
        return False
    
    role_hierarchy = ['member', 'admin', 'owner']
    user_role_idx = role_hierarchy.index(member[0]['role'])
    required_idx = role_hierarchy.index(required_role)
    return user_role_idx >= required_idx

def check_subscription(team_id, required_tier, db):
    """Check if team has required subscription tier"""
    team = db.query(
        "SELECT subscription_tier FROM teams WHERE id = ?", 
        [team_id]
    )
    if not team:
        return False
    
    tier_hierarchy = ['free', 'starter', 'pro', 'enterprise']
    team_tier_idx = tier_hierarchy.index(team[0]['subscription_tier'])
    required_idx = tier_hierarchy.index(required_tier)
    return team_tier_idx >= required_idx

def get_team_features(team_id, db):
    """Get list of features available to team"""
    features = db.query(
        """SELECT f.name 
           FROM features f
           JOIN plan_features pf ON f.id = pf.feature_id
           JOIN teams t ON t.plan_id = pf.plan_id
           WHERE t.id = ?""",
        [team_id]
    )
    return [f['name'] for f in features] if features else []

# Example usage - transparent authentication and authorization
def create_dashboard_app():
    """Example app with transparent auth and team management"""
    from fasthtml.common import *
    
    # 1. Create YOUR app
    app, rt = fast_app()
    
    # 2. Set up database
    db = database("app.db")
    
    # 3. Dashboard route with explicit auth check
    @rt("/dashboard")
    def dashboard(sess):
        # Check authentication explicitly
        if not check_auth(sess):
            return RedirectResponse("/auth/login?next=/dashboard")
        
        # Get user data
        user_id = sess['user_id']
        user = db.query("SELECT * FROM users WHERE id = ?", [user_id])[0]
        
        return PageLayout(
            H1(f"Welcome back, {user['username']}!", cls="text-3xl font-bold mb-6"),
            DashboardStats(user),
            RecentActivity(user, db),
            QuickActions(user),
            title="Dashboard"
        )
    
    # 4. Team settings with explicit role and subscription checks
    @rt("/team/{team_id}/settings")
    def team_settings(team_id: str, sess):
        # Check authentication
        if not check_auth(sess):
            return RedirectResponse(f"/auth/login?next=/team/{team_id}/settings")
        
        # Check team membership and role
        if not check_team_role(sess, team_id, 'admin', db):
            return Response("Admin access required", status_code=403)
        
        # Check subscription
        if not check_subscription(team_id, 'pro', db):
            return Div(
                H2("Upgrade Required", cls="text-2xl font-bold mb-4"),
                P("This feature requires the Pro plan or higher."),
                A("Upgrade Now", href="/billing/upgrade", cls="btn btn-primary mt-4")
            )
        
        # Get team data
        team = db.query("SELECT * FROM teams WHERE id = ?", [team_id])[0]
        user_id = sess['user_id']
        
        return PageLayout(
            H1(f"{team['name']} Settings", cls="text-3xl font-bold mb-6"),
            Tabs(
                Tab("General", TeamGeneralSettings(team, db)),
                Tab("Members", TeamMemberManagement(team, user_id, db)),
                Tab("Billing", TeamBillingSettings(team, db)),
                Tab("Security", TeamSecuritySettings(team, db)),
                Tab("Integrations", TeamIntegrations(team, db))
            ),
            title=f"{team['name']} Settings"
        )
    
    return app

# Test transparent auth checks
#| test
# Mock session
mock_sess = {}

# Test without authentication
assert not check_auth(mock_sess)

# Test with authentication
mock_sess['user_id'] = 1
assert check_auth(mock_sess)

# Mock database for admin check
class MockDB:
    def query(self, sql, params):
        if "is_admin" in sql:
            return [{'is_admin': True}]
        return None

db = MockDB()
assert check_admin(mock_sess, db)

# Test team role check
assert not check_team_role({}, 1, 'admin', db)  # No auth

print("✓ Transparent auth tests passed")
```

#### MonsterUI Component Library Integration

The toolkit leverages MonsterUI's comprehensive component library for beautiful, accessible interfaces:

```python
from launch_kit.ui import *
from monsterui import *

# Authentication Components with MonsterUI - no decorators needed
def SaaSAuthForm(mode="login", providers=None):
    """Beautiful auth forms using MonsterUI components"""
    return Card(
        H2("Welcome Back" if mode == "login" else "Create Account"),
        Form(
            FormField(
                Label("Email"),
                Input(type="email", name="email", required=True)
            ),
            FormField(
                Label("Password"),
                Input(type="password", name="password", required=True)
            ),
            Checkbox(
                name="remember",
                label="Remember me"
            ) if mode == "login" else None,
            Button(
                "Sign In" if mode == "login" else "Sign Up",
                type="submit",
                variant="primary",
                full_width=True
            ),
            Divider("OR") if providers else None,
            Stack(
                *[Button(
                    f"Continue with {provider.title()}",
                    variant="outline",
                    full_width=True,
                    icon=provider,
                    href=f"/auth/{provider}"
                ) for provider in (providers or [])]
            ) if providers else None,
            method="post",
            action="/auth/login" if mode == "login" else "/auth/signup"
        ),
        max_width="sm",
        mx="auto"
    )

# Dashboard Components - simple functions, no decorators
def SaaSDashboard(user, stats):
    """Full dashboard layout with MonsterUI"""
    return DashboardLayout(
        # Sidebar navigation
        Sidebar(
            SidebarHeader(
                Logo("MyApp"),
                UserMenu(user)
            ),
            SidebarNav(
                NavItem("Dashboard", href="/", icon="home"),
                NavItem("Analytics", href="/analytics", icon="chart"),
                NavItem("Customers", href="/customers", icon="users"),
                NavItem("Settings", href="/settings", icon="settings")
            )
        ),
        # Main content
        MainContent(
            PageHeader(
                f"Welcome back, {user['name']}!",
                actions=[
                    Button("New Project", variant="primary", icon="plus")
                ]
            ),
            Grid(
                StatsCard("Total Revenue", f"${stats['revenue']:,.0f}", trend="+12%"),
                StatsCard("Active Users", stats['users'], trend="+5%"),
                StatsCard("Conversion", f"{stats['conversion']:.1f}%", trend="+2.3%"),
                StatsCard("Churn Rate", f"{stats['churn']:.1f}%", trend="-0.5%"),
                cols=4
            ),
            Grid(
                Card(
                    CardHeader("Recent Activity"),
                    Timeline(stats['recent_activity'])
                ),
                Card(
                    CardHeader("Revenue Chart"),
                    Chart(type="area", data=stats['revenue_data'])
                ),
                cols=2
            )
        )
    )

# Pricing Components - no decorators needed
def PricingTable(plans):
    """Beautiful pricing table with MonsterUI"""
    return Container(
        H2("Choose Your Plan", align="center"),
        Grid(
            *[PricingCard(
                title=plan['name'],
                price=plan['price'],
                period=plan['period'],
                features=plan['features'],
                cta=Button(
                    "Get Started" if not plan.get('popular') else "Start Free Trial",
                    variant="primary" if plan.get('popular') else "outline",
                    full_width=True,
                    href=f"/signup?plan={plan['id']}"
                ),
                popular=plan.get('popular', False)
            ) for plan in plans],
            cols=3,
            gap=6
        )
    )

# Form Builder Components - simple functions
def SettingsForm(user):
    """Settings form with validation"""
    return Form(
        Card(
            CardHeader("Profile Settings"),
            Stack(
                FormField(
                    Label("Display Name"),
                    Input(name="name", value=user['name'], required=True)
                ),
                FormField(
                    Label("Email"),
                    Input(type="email", name="email", value=user['email'], required=True)
                ),
                FormField(
                    Label("Bio"),
                    Textarea(name="bio", value=user.get('bio', ''), rows=4)
                ),
                Flex(
                    Button("Cancel", variant="outline"),
                    Button("Save Changes", type="submit", variant="primary"),
                    justify="end",
                    gap=2
                )
            )
        ),
        hx_post="/settings/profile",
        hx_target="#notifications"
    )

# Table Components - direct functions
def CustomerTable(customers, actions=True):
    """Rich data table with MonsterUI"""
    return DataTable(
        columns=[
            {"key": "name", "label": "Customer", "sortable": True},
            {"key": "email", "label": "Email", "sortable": True},
            {"key": "plan", "label": "Plan", "badge": True},
            {"key": "mrr", "label": "MRR", "format": "currency"},
            {"key": "status", "label": "Status", "badge": True},
            {"key": "created", "label": "Created", "format": "date"}
        ],
        data=customers,
        actions=[
            {"label": "View", "icon": "eye", "href": "/customers/{id}"},
            {"label": "Edit", "icon": "edit", "href": "/customers/{id}/edit"}
        ] if actions else None,
        selectable=True,
        filterable=True,
        pagination=True
    )
```

### 8. Database Approach (02_database.ipynb)

#### Literate Database Development
Database schema and migrations are developed in notebooks with visual feedback:
```python
#| export
import os
import sqlite3
from typing import Dict, List, Optional, Any
from datetime import datetime
from launch_kit.db import Migration, Schema

class AddTeamsTable(Migration):
    """Add teams table for multi-tenant support"""
    
    version = "001"  # Migration version for ordering
    
    def up(self, db):
        """Apply migration"""
        db.execute("""
            CREATE TABLE teams (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                name TEXT NOT NULL,
                slug TEXT UNIQUE NOT NULL,
                owner_id INTEGER NOT NULL,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                settings JSON DEFAULT '{}',
                subscription_tier TEXT DEFAULT 'free',
                subscription_status TEXT DEFAULT 'active',
                FOREIGN KEY (owner_id) REFERENCES users(id)
            )
        """)
        
        # Create indexes
        db.execute("CREATE INDEX idx_teams_slug ON teams(slug)")
        db.execute("CREATE INDEX idx_teams_owner ON teams(owner_id)")
        
        # Create team_members junction table
        db.execute("""
            CREATE TABLE team_members (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                team_id INTEGER NOT NULL,
                user_id INTEGER NOT NULL,
                role TEXT NOT NULL DEFAULT 'member',
                joined_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (team_id) REFERENCES teams(id) ON DELETE CASCADE,
                FOREIGN KEY (user_id) REFERENCES users(id) ON DELETE CASCADE,
                UNIQUE(team_id, user_id)
            )
        """)
        
        db.execute("CREATE INDEX idx_team_members_team ON team_members(team_id)")
        db.execute("CREATE INDEX idx_team_members_user ON team_members(user_id)")
    
    def down(self, db):
        """Rollback migration"""
        db.execute("DROP TABLE IF EXISTS team_members")
        db.execute("DROP TABLE IF EXISTS teams")

# Test migration in notebook
#| test
# Create in-memory database for testing
test_db = sqlite3.connect(":memory:")

# First create users table (dependency)
test_db.execute("""
    CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        email TEXT UNIQUE NOT NULL
    )
""")

# Apply migration
migration = AddTeamsTable()
migration.up(test_db)

# Verify tables were created
cursor = test_db.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables = [row[0] for row in cursor]
assert 'teams' in tables
assert 'team_members' in tables

# Test inserting data
test_db.execute("INSERT INTO users (id, email) VALUES (1, 'test@example.com')")
test_db.execute("INSERT INTO teams (name, slug, owner_id) VALUES ('Test Team', 'test-team', 1)")
test_db.execute("INSERT INTO team_members (team_id, user_id, role) VALUES (1, 1, 'owner')")

# Verify data
team = test_db.execute("SELECT * FROM teams WHERE slug = 'test-team'").fetchone()
assert team is not None
assert team[1] == 'Test Team'  # name

# Test rollback
migration.down(test_db)
cursor = test_db.execute("SELECT name FROM sqlite_master WHERE type='table'")
tables = [row[0] for row in cursor]
assert 'teams' not in tables
assert 'team_members' not in tables

print("✓ Migration test passed")
```

#### Active Record Pattern
```python
from launch_kit.db import Model

class Project(Model):
    table_name = "projects"
    
    # Relationships
    team = belongs_to(Team)
    members = has_many(User, through="project_members")
    
    # Scopes
    @classmethod
    def active(cls):
        return cls.where(status="active")
    
    # Validations
    def validate(self):
        if not self.name:
            raise ValueError("Project name is required")
```

### 9. Testing Support (17_testing.ipynb)

#### nbdev Testing Philosophy
Tests are written inline with the code in notebooks, making them part of the documentation:

```python
# In 17_testing.ipynb
#| doc
"""
# Testing Utilities

This notebook provides testing helpers specifically designed for FastHTML SaaS apps.
All test utilities are demonstrated with examples that also serve as tests themselves.
"""

#| export
import os
import asyncio
import sqlite3
import tempfile
from typing import Dict, Any, Optional
from datetime import datetime
from contextlib import contextmanager

class SaaSTestCase:
    """Base test case with SaaS-specific helpers"""
    
    def __init__(self):
        self.app = None
        self.client = None
        self.db = None
        self.session = {}
        
    def setup(self):
        """Set up test environment"""
        # Create test database
        self.db_file = tempfile.NamedTemporaryFile(delete=False)
        self.db = sqlite3.connect(self.db_file.name)
        
        # Create test app transparently
        from fasthtml.common import fast_app
        from launch_kit.database import database
        
        self.app, self.rt = fast_app()
        self.test_db = database(self.db_file.name)
        
        # Run migrations
        from launch_kit.db import run_migrations
        run_migrations(self.db)
        
    def teardown(self):
        """Clean up test environment"""
        self.db.close()
        self.db_file.close()
        os.unlink(self.db_file.name)
    
    def login_as(self, user):
        """Log in as a specific user for testing"""
        from launch_kit.auth import create_session
        session_token = create_session(user.id)
        self.session['session'] = session_token
        return session_token
        
    def create_user(self, **kwargs):
        """Create a test user with defaults"""
        from launch_kit.auth import hash_password
        defaults = {
            'username': 'testuser',
            'email': 'test@example.com',
            'password': 'testpass123!',
            'email_verified': True,
            'is_active': True
        }
        defaults.update(kwargs)
        
        # Hash password if provided
        if 'password' in defaults:
            password = defaults.pop('password')
            defaults['password_hash'] = hash_password(password)
        
        # Insert user
        cursor = self.db.execute(
            "INSERT INTO users (username, email, password_hash, email_verified, is_active) VALUES (?, ?, ?, ?, ?)",
            (defaults['username'], defaults['email'], defaults['password_hash'], 
             defaults['email_verified'], defaults['is_active'])
        )
        user_id = cursor.lastrowid
        
        # Return user object
        from launch_kit.models import User
        return User(id=user_id, **defaults)
    
    def create_team(self, owner, **kwargs):
        """Create a test team"""
        defaults = {
            'name': 'Test Team',
            'slug': 'test-team',
            'subscription_tier': 'free'
        }
        defaults.update(kwargs)
        
        cursor = self.db.execute(
            "INSERT INTO teams (name, slug, owner_id, subscription_tier) VALUES (?, ?, ?, ?)",
            (defaults['name'], defaults['slug'], owner.id, defaults['subscription_tier'])
        )
        team_id = cursor.lastrowid
        
        # Add owner as team member
        self.db.execute(
            "INSERT INTO team_members (team_id, user_id, role) VALUES (?, ?, ?)",
            (team_id, owner.id, 'owner')
        )
        
        from launch_kit.models import Team
        return Team(id=team_id, owner_id=owner.id, **defaults)
        
    def assertSubscriptionActive(self, team, tier=None):
        """Assert team has active subscription"""
        assert team.subscription_status == "active", f"Expected active subscription, got {team.subscription_status}"
        if tier:
            assert team.subscription_tier == tier, f"Expected {tier} tier, got {team.subscription_tier}"
    
    def assertEmailSent(self, to: str, subject: str = None):
        """Assert email was sent (when using console provider)"""
        # Check console output or email log
        # Implementation depends on email provider mock
        pass
    
    @contextmanager
    def assertRaises(self, exception_type):
        """Context manager for exception assertions"""
        try:
            yield
            raise AssertionError(f"Expected {exception_type.__name__} but no exception was raised")
        except exception_type:
            pass  # Expected
        except Exception as e:
            raise AssertionError(f"Expected {exception_type.__name__} but got {type(e).__name__}: {e}")

# Example test that also documents usage
#| test
def test_subscription_upgrade():
    """This test demonstrates the subscription upgrade flow"""
    test_case = SaaSTestCase()
    test_case.setup()
    
    # Create test data
    user = test_case.create_user()
    team = test_case.create_team(owner=user)
    
    # Log in as user
    test_case.login_as(user)
    
    # Simulate upgrade by updating database
    test_case.db.execute(
        "UPDATE teams SET subscription_tier = ? WHERE id = ?",
        ('pro', team.id)
    )
    test_case.db.commit()
    
    # Verify results
    result = test_case.db.execute(
        "SELECT subscription_tier FROM teams WHERE id = ?",
        (team.id,)
    ).fetchone()
    assert result[0] == 'pro'
    
    test_case.teardown()
    
# Run the test
test_subscription_upgrade()
print("✓ Subscription upgrade test passed")

# Example of visual test result display
#| test
def run_all_tests():
    """Run all tests and display results visually"""
    test_results = [
        {"name": "test_user_creation", "status": "passed", "time": 0.023},
        {"name": "test_authentication", "status": "passed", "time": 0.145},
        {"name": "test_team_creation", "status": "passed", "time": 0.067},
        {"name": "test_subscription_upgrade", "status": "passed", "time": 0.089},
        {"name": "test_admin_access", "status": "failed", "time": 0.034, 
         "error": "AssertionError: Expected 403 but got 200"},
    ]
    
    # Display test summary
    passed = sum(1 for t in test_results if t["status"] == "passed")
    failed = sum(1 for t in test_results if t["status"] == "failed")
    total_time = sum(t["time"] for t in test_results)
    
    from IPython.display import HTML, display
    
    html = f"""
    <div style="border: 1px solid #ddd; padding: 20px; border-radius: 8px; margin: 10px 0;">
        <h3>Test Results</h3>
        <div style="display: flex; gap: 20px; margin: 20px 0;">
            <div style="text-align: center;">
                <div style="font-size: 32px; font-weight: bold; color: #10b981;">{passed}</div>
                <div>Passed</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 32px; font-weight: bold; color: #ef4444;">{failed}</div>
                <div>Failed</div>
            </div>
            <div style="text-align: center;">
                <div style="font-size: 32px; font-weight: bold;">{total_time:.3f}s</div>
                <div>Total Time</div>
            </div>
        </div>
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="border-bottom: 2px solid #ddd;">
                    <th style="text-align: left; padding: 8px;">Test</th>
                    <th style="text-align: left; padding: 8px;">Status</th>
                    <th style="text-align: left; padding: 8px;">Time</th>
                </tr>
            </thead>
            <tbody>
    """
    
    for test in test_results:
        status_color = "#10b981" if test["status"] == "passed" else "#ef4444"
        status_icon = "✓" if test["status"] == "passed" else "✗"
        html += f"""
                <tr style="border-bottom: 1px solid #eee;">
                    <td style="padding: 8px;">{test['name']}</td>
                    <td style="padding: 8px; color: {status_color};">{status_icon} {test['status']}</td>
                    <td style="padding: 8px;">{test['time']:.3f}s</td>
                </tr>
        """
        if test.get('error'):
            html += f"""
                <tr>
                    <td colspan="3" style="padding: 8px; color: #666; font-size: 14px;">
                        {test['error']}
                    </td>
                </tr>
            """
    
    html += """
            </tbody>
        </table>
    </div>
    """
    
    display(HTML(html))
    
    # Also show coverage report
    coverage_html = """
    <div style="border: 1px solid #ddd; padding: 20px; border-radius: 8px; margin: 10px 0;">
        <h3>Coverage Report</h3>
        <div style="margin: 10px 0;">
            <div style="background: #f3f4f6; border-radius: 4px; overflow: hidden;">
                <div style="background: #10b981; color: white; padding: 4px 10px; width: 92%;">
                    92% Coverage
                </div>
            </div>
        </div>
        <table style="width: 100%; margin-top: 20px;">
            <tr><td>launch_kit/core.py</td><td style="text-align: right;">98%</td></tr>
            <tr><td>launch_kit/auth.py</td><td style="text-align: right;">95%</td></tr>
            <tr><td>launch_kit/admin.py</td><td style="text-align: right;">89%</td></tr>
            <tr><td>launch_kit/billing.py</td><td style="text-align: right;">87%</td></tr>
        </table>
    </div>
    """
    display(HTML(coverage_html))

# Run the visual test
run_all_tests()
```

#### Visual Test Results
Notebooks can display test results visually:
```python
#| test
# Run all tests and display results
results = run_notebook_tests()
display_test_summary(results)  # Shows green checkmarks, coverage, etc.
```

### 10. Deployment Support

#### Configuration
```python
# config/production.py
import os
from fasthtml.common import *
from launch_kit.database import database
from launch_kit.auth import AuthRoutes
from launch_kit.admin import AdminRoutes

# Create production app with explicit configuration
def create_production_app():
    # Get configuration from environment
    DATABASE_URL = os.environ.get("DATABASE_URL", "sqlite:///prod.db")
    SECRET_KEY = os.environ.get("SECRET_KEY")
    
    # Create app with production settings
    app, rt = fast_app(
        secret_key=SECRET_KEY,
        debug=False,
        hdrs=(MonsterUI(),)
    )
    
    # Set up database
    db = database(DATABASE_URL)
    
    # Create route handlers
    auth = AuthRoutes(db)
    admin = AdminRoutes(db)
    
    # Wire up routes explicitly
    @rt("/auth/login")
    def login_page():
        return auth.login_page()
    
    @rt("/auth/login", methods=["POST"])
    async def login(req, sess):
        return await auth.login(req, sess)
    
    # ... wire up other routes as needed
    
    return app
```

#### Deployment Files
- Dockerfile with multi-stage build
- docker-compose.yml for local dev
- Kubernetes manifests
- GitHub Actions workflows
- Render.com blueprint
- Fly.io configuration

### 11. Documentation & Examples

#### nbdev-Generated Documentation
The entire documentation is generated from notebooks, ensuring it's always up-to-date:

- **Interactive Documentation**: All code examples are runnable
- **API Reference**: Auto-generated from notebook docstrings
- **Visual Examples**: UI components shown with rendered output
- **Test Results**: Tests run during doc generation ensure examples work

#### Tutorial Notebooks
Each tutorial is a complete, runnable notebook:
```
tutorials/
├── 01_getting_started.ipynb    # Basic setup and first app
├── 02_authentication.ipynb     # Deep dive into auth
├── 03_building_admin.ipynb     # Creating admin interfaces
├── 04_deployment.ipynb         # Production deployment
└── 05_advanced_patterns.ipynb  # Complex use cases
```

#### Example Applications
Complete example apps as notebooks:
- **Simple SaaS**: `examples/01_quickstart.ipynb`
- **Multi-tenant B2B**: `examples/02_b2b_saas.ipynb`
- **API Platform**: `examples/03_api_first.ipynb`
- **Marketplace**: `examples/04_marketplace.ipynb`

Each example can be:
1. Run interactively in Jupyter
2. Exported to a standalone Python app
3. Used as a template for new projects

### 12. Future Roadmap

Future modules, each developed as notebooks:
- **Analytics Module**: User tracking, funnel analysis
- **A/B Testing**: Feature flag based experiments  
- **Internationalization**: Multi-language support
- **Compliance**: GDPR tools, data export
- **Marketplace**: App marketplace functionality
- **Mobile API**: React Native / Flutter integration
- **AI Integration**: LLM features, embeddings
- **Real-time**: WebSocket support for live features

## Summary

The `launch-kit` package, built with nbdev and MonsterUI, provides:

1. **Literate Programming**: All code developed in notebooks with inline documentation and tests
2. **Interactive Development**: See MonsterUI components and test results directly in notebooks
3. **Beautiful UI by Default**: MonsterUI provides professional, accessible components out of the box
4. **Automatic Documentation**: Beautiful docs generated from notebooks
5. **Integrated Testing**: Tests live with the code they test
6. **FastHTML + MonsterUI Alignment**: Leveraging the best of both frameworks

### MonsterUI Integration Benefits

The integration with MonsterUI as the default UI framework provides:

- **Consistent Design System**: All components follow MonsterUI's design principles
- **Built-in Accessibility**: WCAG compliant components without extra effort
- **Dark Mode Support**: Automatic theme switching with MonsterUI's theming system
- **Responsive by Default**: Mobile-first components that work on all devices
- **Rich Component Library**: From simple buttons to complex data tables and charts
- **Minimal Code**: Create beautiful interfaces with less code than raw HTML
- **Type Safety**: Full TypeScript support for better IDE experience

This approach combines three powerful tools:
- The rapid development and excellent documentation of **nbdev**
- The simplicity and power of **FastHTML** for web applications
- The beautiful, accessible components of **MonsterUI**
- Production-ready SaaS features out of the box

The result is a toolkit that not only accelerates SaaS development but also ensures professional, accessible interfaces from day one, making it easy for developers to build beautiful applications without being design experts.