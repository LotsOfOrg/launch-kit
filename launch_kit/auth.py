"""Secure, simple authentication utilities for FastHTML applications"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_auth.ipynb.

# %% auto 0
__all__ = ['hash_password', 'verify_password', 'create_auth_token', 'user_auth_before', 'get_user_from_session',
           'verify_auth_token']

# %% ../nbs/00_auth.ipynb 4
import bcrypt
import secrets
from typing import Optional, Dict, Any
from functools import wraps

# %% ../nbs/00_auth.ipynb 7
def hash_password(password: str) -> str:
    """Hash a password using bcrypt with a cost factor of 12.
    
    Args:
        password: Plain text password to hash
        
    Returns:
        Hashed password as a string for database storage
    """
    # Cost factor of 12 is recommended for 2024
    # This takes ~250ms on modern hardware
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# %% ../nbs/00_auth.ipynb 9
def verify_password(password: str, hashed: str) -> bool:
    """Verify a password against a bcrypt hash.
    
    Uses timing-safe comparison to prevent timing attacks.
    
    Args:
        password: Plain text password to verify
        hashed: Bcrypt hash from the database
        
    Returns:
        True if password matches, False otherwise
    """
    try:
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed.encode('utf-8')
        )
    except (ValueError, TypeError):
        # Invalid hash format
        return False

# %% ../nbs/00_auth.ipynb 14
def create_auth_token(user_id: int) -> str:
    """Create a secure authentication token for a user.
    
    Args:
        user_id: ID of the user to create token for
        
    Returns:
        Secure random token string
        
    Note:
        In production, you'd store this token in your database
        with an expiration date and associate it with the user.
    """
    # Generate a secure random token
    token = secrets.token_urlsafe(32)
    # In a real app, you'd store: token -> user_id mapping in database
    return f"{user_id}:{token}"

# %% ../nbs/00_auth.ipynb 17
def user_auth_before(req, sess, login_path='/login'):
    """Beforeware function to check authentication status.
    
    Based on FastHTML's recommended authentication pattern.
    Sets req.scope['auth'] for automatic injection in route handlers.
    
    Args:
        req: FastHTML request object
        sess: FastHTML session object
        login_path: Path to redirect to when not authenticated (default: '/login')
        
    Returns:
        RedirectResponse to login_path if not authenticated
        
    Usage:
        beforeware = Beforeware(
            user_auth_before,
            skip=['/login', '/signup', '/static/.*']
        )
        
        # Or with custom login path:
        def auth_custom_login(req, sess):
            return user_auth_before(req, sess, login_path='/auth/login')
            
        beforeware = Beforeware(
            auth_custom_login,
            skip=['/auth/login', '/auth/signup', '/static/.*']
        )
    """
    from fasthtml.common import RedirectResponse
    auth = req.scope['auth'] = sess.get('auth', None)
    if not auth: 
        return RedirectResponse(login_path, status_code=303)

# %% ../nbs/00_auth.ipynb 18
def get_user_from_session(sess) -> Optional[Dict[str, Any]]:
    """Extract user data from session.
    
    Args:
        sess: FastHTML session object
        
    Returns:
        User dictionary if authenticated, None otherwise
        
    Note:
        With FastHTML's authentication pattern, you can also access 
        auth status via the 'auth' parameter in route handlers.
    """
    if sess.get('auth') and 'user' in sess:
        return sess['user']
    return None

# %% ../nbs/00_auth.ipynb 25
def verify_auth_token(token: str) -> Optional[int]:
    """Verify an authentication token and return the user ID.
    
    Args:
        token: Authentication token to verify
        
    Returns:
        User ID if token is valid, None otherwise
        
    Note:
        In production, you'd look up this token in your database
        and check expiration.
    """
    try:
        # Simple parsing for demo - in production, look up in database
        parts = token.split(':', 1)
        if len(parts) == 2:
            user_id = int(parts[0])
            # In real app: verify token exists in DB and not expired
            return user_id
    except (ValueError, TypeError):
        pass
    return None
