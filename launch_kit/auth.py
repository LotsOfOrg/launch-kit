"""Secure, simple authentication utilities for FastHTML applications"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_auth.ipynb.

# %% auto 0
__all__ = ['hash_password', 'verify_password', 'user_auth_before', 'get_user_from_session', 'create_auth_token',
           'verify_auth_token']

# %% ../nbs/00_auth.ipynb 3
import bcrypt
import secrets
from typing import Optional, Dict, Any
from functools import wraps

# %% ../nbs/00_auth.ipynb 8
def hash_password(password: str) -> str:
    """Hash a password using bcrypt with a cost factor of 12.
    """
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# %% ../nbs/00_auth.ipynb 11
def verify_password(password: str, hashed: str) -> bool:
    """Verify a password against a bcrypt hash.
    """
    try:
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed.encode('utf-8')
        )
    except (ValueError, TypeError):
        # Invalid hash format
        return False

# %% ../nbs/00_auth.ipynb 19
def user_auth_before(req, sess, login_path='/login'):
    """Beforeware function to check authentication status.
    """
    from fasthtml.common import RedirectResponse
    auth = req.scope['auth'] = sess.get('auth', None)
    if not auth: 
        return RedirectResponse(login_path, status_code=303)

# %% ../nbs/00_auth.ipynb 22
def get_user_from_session(sess) -> Optional[Dict[str, Any]]:
    """Extract user data dictionary from session.
    """
    if sess.get('auth') and 'user' in sess:
        return sess['user']
    return None

# %% ../nbs/00_auth.ipynb 28
def create_auth_token(user_id: int) -> str:
    """Create a secure authentication token for a user.
    """
    token = secrets.token_urlsafe(32)
    # In a real app, you'd store: token -> user_id mapping in database
    return f"{user_id}:{token}"

# %% ../nbs/00_auth.ipynb 31
def verify_auth_token(token: str) -> Optional[int]:
    """Verify an authentication token and return the user ID.
    """
    try:
        # Simple parsing for demo - in production, look up in database
        parts = token.split(':', 1)
        if len(parts) == 2:
            user_id = int(parts[0])
            # In real app: verify token exists in DB and not expired
            return user_id
    except (ValueError, TypeError):
        pass
    return None
