"""Secure, simple authentication utilities for FastHTML applications"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_auth.ipynb.

# %% auto 0
__all__ = ['hash_password', 'verify_password', 'User', 'init_auth_tables', 'create_user', 'get_user_by_id', 'get_user_by_email',
           'get_user_by_username', 'update_user', 'delete_user', 'authenticate_user', 'check_permission', 'track_login',
           'is_username_available', 'is_email_available', 'validate_user_data', 'user_auth_before',
           'get_user_from_session', 'create_auth_token', 'verify_auth_token']

# %% ../nbs/00_auth.ipynb 3
import bcrypt
import secrets
from typing import Optional, Dict, Any, List
from functools import wraps
from dataclasses import dataclass, field
from datetime import datetime
from fastlite import *
from apswutils.db import NotFoundError
import sqlite3

# %% ../nbs/00_auth.ipynb 8
def hash_password(password: str # The password to hash
                  ) -> str:     # The hashed password
    """Hash a password using bcrypt with a cost factor of 12.
    """
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# %% ../nbs/00_auth.ipynb 11
def verify_password(password: str, # The password to verify
                    hashed: str    # The hashed password to compare against
                    ) -> bool:     # True if password matches hash, False otherwise
    """Verify a password against a bcrypt hash.
    """
    try:
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed.encode('utf-8')
        )
    except (ValueError, TypeError):
        # Invalid hash format
        return False

# %% ../nbs/00_auth.ipynb 14
@dataclass
class User:
    """User model for authentication.
    """
    username: str # The unique username
    email: str # The unique email address
    password_hash: str # The hashed password
    role: str = 'user' # The user role
    is_active: bool = True # Whether the user is active
    created_at: datetime = field(default_factory=datetime.utcnow) # The creation timestamp
    updated_at: datetime = field(default_factory=datetime.utcnow) # The last update timestamp
    id: Optional[int] = None

# %% ../nbs/00_auth.ipynb 15
def init_auth_tables(db_path: str = 'data.db' # The path to the SQLite database file
                    ) -> Database:            # The FastHTML Database instance configured with the User table
    """Creates the users table with proper schema and indexes. Uses FastHTML's MiniDataAPI for simple, transparent database operations.
    """
    # Create database connection using fastlite
    db = Database(db_path)
    
    # Create users table using MiniDataAPI pattern
    # Note: fastlite creates table name as 'user' (singular) by default
    users = db.create(User, pk='id')
    
    # Create indexes for performance
    with db.conn:
        db.conn.execute('''
            CREATE INDEX IF NOT EXISTS idx_user_email 
            ON user(email)
        ''')
        db.conn.execute('''
            CREATE INDEX IF NOT EXISTS idx_user_username 
            ON user(username)
        ''')
        db.conn.execute('''
            CREATE UNIQUE INDEX IF NOT EXISTS idx_user_email_unique 
            ON user(email)
        ''')
        db.conn.execute('''
            CREATE UNIQUE INDEX IF NOT EXISTS idx_user_username_unique 
            ON user(username)
        ''')
    
    return db

# %% ../nbs/00_auth.ipynb 18
def create_user(db: Database,                  # The FastHTML Database instance
                username: str,                 # The unique username
                email: str,                    # The unique email address
                password: str,                 # The plain text password
                role: str = 'user',            # The user role
                table_name: str = 'user'       # The table name
                ) -> Optional[Dict[str, Any]]: # The created user dict or None if user already exists
    """Create a new user in the database.
    """
    users = db[table_name]
    
    # Check if user already exists
    if users(where="email = ? OR username = ?", where_args=[email, username]):
        return None
    
    # Create user with hashed password
    user_data = User(
        username=username,
        email=email,
        password_hash=hash_password(password),
        role=role
    )
    
    # Insert using MiniDataAPI
    return users.insert(user_data)

# %% ../nbs/00_auth.ipynb 19
def get_user_by_id(db: Database,                  # The FastHTML Database instance
                   user_id: int,                  # The user ID
                   table_name: str = 'user'       # The table name
                   ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by ID.
    """
    users = db[table_name]
    try:
        return users[user_id]
    except NotFoundError:
        return None

# %% ../nbs/00_auth.ipynb 20
def get_user_by_email(db: Database,                  # The FastHTML Database instance
                      email: str,                    # The email address
                      table_name: str = 'user'       # The table name
                      ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by email address.
    """
    users = db[table_name]
    results = users(where="email = ?", where_args=[email])
    return results[0] if results else None

# %% ../nbs/00_auth.ipynb 21
def get_user_by_username(db: Database,                  # The FastHTML Database instance
                         username: str,                 # The username
                         table_name: str = 'user'       # The table name
                         ) -> Optional[Dict[str, Any]]: # The user dict or None if not found
    """Get user by username.
    """
    users = db[table_name]
    results = users(where="username = ?", where_args=[username])
    return results[0] if results else None

# %% ../nbs/00_auth.ipynb 22
def update_user(db: Database,                          # The FastHTML Database instance
                user_id: int,                          # The user ID
                table_name: str = 'user',              # The table name
                **kwargs) -> Optional[Dict[str, Any]]: # The updated user dict or None if not found
    """Update user attributes.
    """
    users = db[table_name]
    
    # Get existing user
    try:
        user = users[user_id]
        if not user:
            return None
    except NotFoundError:
        return None
    
    # Update timestamp
    kwargs['updated_at'] = datetime.utcnow()
    
    # If password is being updated, hash it
    if 'password' in kwargs:
        kwargs['password_hash'] = hash_password(kwargs.pop('password'))
    
    # Update using MiniDataAPI - fastlite expects the record as first arg, then kwargs
    updated_user = dict(user)  # Make a copy
    updated_user.update(kwargs)  # Apply updates
    return users.update(updated_user)

# %% ../nbs/00_auth.ipynb 23
def delete_user(db: Database,            # The FastHTML Database instance
                user_id: int,            # The user ID
                table_name: str = 'user' # The table name
                ) -> bool:               # True if deleted, False if not found
    """Delete a user from the database.
    """
    users = db[table_name]
    
    # Check if user exists
    try:
        user = users[user_id]
        if not user:
            return False
    except NotFoundError:
        return False
    
    # Delete using MiniDataAPI
    users.delete(user_id)
    return True

# %% ../nbs/00_auth.ipynb 25
def authenticate_user(db: Database,                  # The FastHTML Database instance
                      username_or_email: str,        # The username or email address
                      password: str,                 # The plain text password
                      table_name: str = 'user'       # The table name
                      ) -> Optional[Dict[str, Any]]: # The authenticated user dict or None if invalid credentials
    """Authenticate a user by username/email and password.
    """
    # Try to find user by email first, then username
    user = get_user_by_email(db, username_or_email, table_name)
    if not user:
        user = get_user_by_username(db, username_or_email, table_name)
    
    # Verify password if user found
    if user and verify_password(password, user['password_hash']):
        return user
    
    return None

# %% ../nbs/00_auth.ipynb 26
def check_permission(user: User,                  # The user object to check
                     required_role: str = 'admin' # The required role
                     ) -> bool:                   # True if user has permission, False otherwise
    """Check if user has required role/permission. Simple role-based permission check. Can be extended for more complex permissions.
    """
    if not user or not user.is_active:
        return False
    
    # Simple role hierarchy: admin > user
    if required_role == 'user':
        return True  # All authenticated users have 'user' permission
    
    return user.role == required_role

# %% ../nbs/00_auth.ipynb 27
def track_login(db: Database, # The FastHTML Database instance
                user_id: int, # The user ID
                ip_address: Optional[str] = None, # The IP address of the login
                user_agent: Optional[str] = None, # The user agent string
                table_name: str = 'user_logins' # The table name
                ) -> None: # The login record
    """Track user login for security and analytics. Creates a login record with timestamp and metadata.
    """
    # Create login tracking table if it doesn't exist
    db.conn.execute(f'''
        CREATE TABLE IF NOT EXISTS {table_name} (
            id INTEGER PRIMARY KEY AUTOINCREMENT,
            user_id INTEGER NOT NULL,
            login_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
            ip_address TEXT,
            user_agent TEXT,
            FOREIGN KEY (user_id) REFERENCES user(id)
        )
    ''')
    
    # Insert login record
    db.conn.execute(f'''
        INSERT INTO {table_name} (user_id, ip_address, user_agent)
        VALUES (?, ?, ?)
    ''', (user_id, ip_address, user_agent))

# %% ../nbs/00_auth.ipynb 29
def is_username_available(db: Database, # The FastHTML Database instance
                          username: str, # The username to check
                          table_name: str = 'user' # The table name
                          ) -> bool: # True if username is available, False if taken
    """Check if username is available for registration.
    """
    return get_user_by_username(db, username, table_name) is None

# %% ../nbs/00_auth.ipynb 30
def is_email_available(db: Database, # The FastHTML Database instance
                       email: str, # The email address to check
                       table_name: str = 'user' # The table name
                       ) -> bool: # True if email is available, False if taken
    """Check if email is available for registration.
    """
    return get_user_by_email(db, email, table_name) is None

# %% ../nbs/00_auth.ipynb 31
def validate_user_data(username: str, # The username to validate
                       email: str, # The email address to validate
                       password: str # The password to validate
                       ) -> List[str]: # The list of validation errors (empty if valid)
    """Validate user registration data.
    """
    errors = []
    
    # Username validation
    if not username or len(username) < 3:
        errors.append("Username must be at least 3 characters long")
    elif not username.replace('_', '').replace('-', '').isalnum():
        errors.append("Username can only contain letters, numbers, underscores, and hyphens")
    
    # Email validation (basic)
    if not email or '@' not in email:
        errors.append("Invalid email address")
    else:
        parts = email.split('@')
        if len(parts) != 2 or not parts[0] or not parts[1] or '.' not in parts[1]:
            errors.append("Invalid email address")
    
    # Password validation
    if not password or len(password) < 8:
        errors.append("Password must be at least 8 characters long")
    
    return errors

# %% ../nbs/00_auth.ipynb 43
def user_auth_before(req, # The FastHTML Request object
                     sess, # The FastHTML Session object
                     login_path='/login' # The login path
                     ): # The authenticated user dict or RedirectResponse if not authenticated
    """Beforeware function to check authentication status.
    """
    from fasthtml.common import RedirectResponse
    auth = req.scope['auth'] = sess.get('auth', None)
    if not auth: 
        return RedirectResponse(login_path, status_code=303)

# %% ../nbs/00_auth.ipynb 46
def get_user_from_session(sess                           # The FastHTML Session object
                          ) -> Optional[Dict[str, Any]]: # The user data dict or None if not authenticated
    """Extract user data dictionary from session.
    """
    if sess.get('auth') and 'user' in sess:
        return sess['user']
    return None

# %% ../nbs/00_auth.ipynb 52
def create_auth_token(user_id: int # The user ID
                      ) -> str:    # The authentication token
    """Create a secure authentication token for a user.
    """
    token = secrets.token_urlsafe(32)
    # In a real app, you'd store: token -> user_id mapping in database
    return f"{user_id}:{token}"

# %% ../nbs/00_auth.ipynb 55
def verify_auth_token(token: str # The authentication token
                      ) -> Optional[int]: # The user ID or None if invalid
    """Verify an authentication token and return the user ID.
    """
    try:
        # Simple parsing for demo - in production, look up in database
        parts = token.split(':', 1)
        if len(parts) == 2:
            user_id = int(parts[0])
            # In real app: verify token exists in DB and not expired
            return user_id
    except (ValueError, TypeError):
        pass
    return None
