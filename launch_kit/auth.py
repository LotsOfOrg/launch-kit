"""Simple, transparent authentication utilities for FastHTML applications"""

# AUTOGENERATED! DO NOT EDIT! File to edit: ../nbs/00_auth.ipynb.

# %% auto 0
__all__ = ['hash_password', 'verify_password', 'get_user_from_session', 'create_auth_token', 'verify_auth_token']

# %% ../nbs/00_auth.ipynb 3
import bcrypt
import secrets
from typing import Optional, Dict, Any
from functools import wraps

# %% ../nbs/00_auth.ipynb 6
def hash_password(password: str) -> str:
    """Hash a password using bcrypt with a cost factor of 12.
    
    Args:
        password: Plain text password to hash
        
    Returns:
        Hashed password as a string for database storage
    """
    # Cost factor of 12 is recommended for 2024
    # This takes ~250ms on modern hardware
    salt = bcrypt.gensalt(rounds=12)
    hashed = bcrypt.hashpw(password.encode('utf-8'), salt)
    return hashed.decode('utf-8')

# %% ../nbs/00_auth.ipynb 7
def verify_password(password: str, hashed: str) -> bool:
    """Verify a password against a bcrypt hash.
    
    Uses timing-safe comparison to prevent timing attacks.
    
    Args:
        password: Plain text password to verify
        hashed: Bcrypt hash from the database
        
    Returns:
        True if password matches, False otherwise
    """
    try:
        return bcrypt.checkpw(
            password.encode('utf-8'), 
            hashed.encode('utf-8')
        )
    except (ValueError, TypeError):
        # Invalid hash format
        return False

# %% ../nbs/00_auth.ipynb 10
def get_user_from_session(sess) -> Optional[Dict[str, Any]]:
    """Extract user data from session.
    
    Args:
        sess: FastHTML session object
        
    Returns:
        User dictionary if authenticated, None otherwise
        
    Note:
        With FastHTML's built-in auth, you can also access auth status
        via the 'auth' parameter in route handlers.
    """
    if sess.get('auth') and 'user' in sess:
        return sess['user']
    return None

# %% ../nbs/00_auth.ipynb 13
def create_auth_token(user_id: int) -> str:
    """Create a secure authentication token for a user.
    
    Args:
        user_id: ID of the user to create token for
        
    Returns:
        Secure random token string
        
    Note:
        In production, you'd store this token in your database
        with an expiration date and associate it with the user.
    """
    # Generate a secure random token
    token = secrets.token_urlsafe(32)
    # In a real app, you'd store: token -> user_id mapping in database
    return f"{user_id}:{token}"

# %% ../nbs/00_auth.ipynb 14
def verify_auth_token(token: str) -> Optional[int]:
    """Verify an authentication token and return the user ID.
    
    Args:
        token: Authentication token to verify
        
    Returns:
        User ID if token is valid, None otherwise
        
    Note:
        In production, you'd look up this token in your database
        and check expiration.
    """
    try:
        # Simple parsing for demo - in production, look up in database
        parts = token.split(':', 1)
        if len(parts) == 2:
            user_id = int(parts[0])
            # In real app: verify token exists in DB and not expired
            return user_id
    except (ValueError, TypeError):
        pass
    return None
